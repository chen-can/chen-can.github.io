# 面试题
## Doctype作用？
告知浏览器的解析器用什么文档标准解析这个文档
## XML 和 JSON 的区别？
JSON：体积小，速度快，阅读性强，更易解析
## JS的基本数据类型和引用数据类型
基本数据类型：undefined、null、boolean、number、string、symbol（ES6）、bigInt（谷歌67版本）7——占用内存小，固定大小，一般存在栈内存当中，内存自动释放
引用数据类型：object、array、function——占用内存大，不固定大小，一般存在堆内存当中，内存不会释放，指针是在栈内存中
## let、var、const的区别
var 没有块级作用域，支持变量提升。
let 有块级作用域，不支持变量提升。不允许重复声明，暂存性死区。不能通过window.变量名进行访问.
const 有块级作用域，不支持变量提升，不允许重复声明，暂存性死区。声明一个变量一旦声明就不能改变，改变报错。
暂存性死区：就是在我们声明之前是不能访问它们的。如果访问就抛出ReferenceError 错误
## 继承原理
复制父类的属性和方法来重写子类的原型对象
## 浅拷贝:
1、Object.assign方法来实现
2、扩展运算符 ...obj
## 深拷贝:
1、JSON.parse(JSON.stringfy(object)) 此方法不支持function拷贝
2、手写递归方法去实现
## 简述cookie、localstorage、seesionstorage
| 名称 | 大小 | 网络请求  | 生命周期 |
| --- | --- | --- | --- |
| cookie | 4kb左右 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 默认是关闭浏览器后失效, 但是也可以设置过期时间 |
| localstorage | 5M | 仅在浏览器中保存，不参与和服务器的通信  | 除非手动被清除，否则永久保存 |
| SessionStorage | 5M | 仅在浏览器中保存，不参与和服务器的通信  | 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间 |
## get和post请求的区别
| get | post |
| --- | --- |
| 默认参数长度有限制    （不同浏览器长度不一致，最大2048）（可通过浏览器和服务器配置） | 默认参数长度无限制（可通过浏览器和服务器配置） |
| 会把请求的数据附加在url上 | 请求会把数据附加在请求体中 |
| 是明文传输 | 不是明文传输（相对来说不是明文因为可以用开发工具可以看到） |
| 请求能缓存 | 不能缓存 |
| 速度快（数据和请求头一起发送） | 速度慢（因为先将请求头发送给服务器进行确认） |
## 常用的请求方式及作用
| get | 查询，获取 |
| --- | --- |
| post | 新建，更新 |
| put | 更新 |
| delete | 删除 |
## http和https区别
| http  | https |
| --- | --- |
| 80端口 | 443端口 |
| 无需申请证书 | 需要申请证书 |
| 超文本传输协议 | ssl加密协议 |
| 快 | 慢（因为会有一个ssl包需要传输） |
## 盒模型
盒模型的组成，由里向外content,padding,border,margin.
box-sizing: content-box 是W3C盒子模型 默认属性
box-sizing: border-box 是IE盒子模型
## 说一下http状态码有那些
200、2开头请求成功
302、3开头重定向
404、4开头客户端请求错误
500、5开头服务器端请求错误
详情见：[https://www.runoob.com/http/http-status-codes.html](https://www.runoob.com/http/http-status-codes.html)
## es6 新特性
模版字符串、箭头函数、解构、扩展运算符、函数默认参数、块级作用域、类、导入/导出  	
## 用一句话说下什么是javaScript
简称js,一种轻量级，单线程，解释性（翻译）的脚本语言
## 什么是前后端分离
前端指的是浏览器端，后端指的是服务器端
前后端分离最大的好处就是代码可维护性强，提高开发效率
## 什么是重排和重绘
**重排**：部分或整个渲染树需要重新分析并且需要重新计算节点尺寸
**重绘**：节点属性或样式发生变化
## call、apply、bind区别
相同点：都是重定向this指针的方法。
不同点：call和apply的第二个参数不相同，call是若干个参数的列表。apply是一个数组
## 什么是原型链
实例会查看自己是否有这个属性如果没有的话会通过__proto__属性找原型对象， 这样一环扣一环就是原型链
## css水平、垂直居中的写法，请至少写出4种
#### 水平居中
行内元素: text-align: center
块级元素: margin: 0 auto
position:absolute +left:50%+ transform:translateX(-50%)
display:flex + justify-content: center
#### 垂直居中
设置line-height 等于height
position：absolute +top:50%+ transform:translateY(-50%)
display:flex + align-items: center
display:table+display:table-cell + vertical-align: middle;
## 项目流程

1. 项目立项
2. 需求评审，对功能进行可行性分析，确定项目周期，分配任务
3. 产品经理用蓝湖创建原形图
4. UI设计师设计效果图
5. 前后端开发
6. 测试如果有bug返回上一部
7. 上线
## 你开发遇到那些难题
1. 和后端合作的时候像一些数据类型不对会产生一些bug或者是服务器的一些问题所以在项目的过程中需要保持沟通和后端一起解决这个问题
2. 兼容性问题，有一些方法在不同机型下会产生不一样的效果，我们做的时候就需要做一些兼容性处理
3. 我们在开发的时候可能会用到一些组件而第三方组件没有提供的时候我们就需要自己去封装
4. 在开发过程中我们可能会需要第三方依赖，有时候不生效或出bug很可能是版本问题
## 网站性能优化
- 代码的优化
   - 尽量用语义化的标签，比较利于搜索引擎的优化
   - css尽量把公共的代码提取出来
   - js尽量把公共的代码封装成函数，script标签尽量写在body下面
   - js中少用全局变量，减少dom操作，减少事件绑定次数
- 页面的优化
   - 减少http请求，在发送请求之前要做一些请求判断，做截流处理
   - 把页面不经常更新的资源放到缓存里面
   - 文件打包压缩
当然优化的方法还有很多，那大体方向就是这样子
## 说一下从url输入到返回请求的过程
1. 进行DNS解析（就是把域名地址解析成IP地址）
   1. 浏览器DNS缓存
   2. 系统DNS缓存
   3. 路由器DNS缓存
   4. 网络运营商DNS缓存
   5. 递归搜索blog.baidu.com
2. 建立TCP连接（三次握手）
   1. 由浏览器发起，告诉服务器，我要发送请求
   2. 由服务器发起，告诉浏览器，我准备好了，你发吧
   3. 由浏览器发起，告诉服务器，我发了，准备接收吧
3. 发送请求
   1. 请求报文
4. 发送响应
   1. 响应报文
5. 渲染页面（不一定按照顺序执行）
   1. 遇见html，浏览器调用html解析器，构建dom树
   2. 遇见style/link，浏览器调用css解析器，构建cssom树
   3. 遇见script，浏览器调用javascript解析器，处理script代码
   4. 将dom树和cssom树合并成渲染树
   5. 根据渲染树计算布局
   6. 将各节点颜色绘制到屏幕上
6. 断开TCP连接（四次挥手）
   1. 由浏览器发起，告诉服务器，我东西发送完了（请求报文）
   2. 由服务器发起，告诉浏览器，我东西接收完了（请求报文），我准备关闭，你也准备吧
   3. 由服务器发起，告诉浏览器，我东西发送完了（响应报文），你准备关闭
   4. 由浏览器发起，告诉服务器，我东西接收完了（响应报文），我准备关闭，你也准备吧
## 其它
如果原型对象上没有返回undefined
v-if 适合不变的数据如请求API动态显示/隐藏
this 在严格模式下返回undefined
事件捕获由高到低，事件冒泡由低到高，事件捕获在事件冒泡前
null==undefined 是因为都转为false 所以为true
相等运算符会进行类型转换，全等运算符不会
null和undefined除自身外比较无法转换 ''==0 true
nan不等于自身
vue.config 改动需要重启项目
轮播图原理
## 在哪个生命周期内调用异步请求

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性
## 简述Vue响应式原理

1. data的属性被转化为gutter和setter,并且记录相应的依赖，当它被改动的时候会通知相应的依赖
2. 所有的组件实例会有它对应的watcher实例，而watcher实例会依赖与相应的setter
3. 当数据变化时setter会被调用，setter会通知对应的watcher,wacher会更新相应的视图
## 说一下v-model的原理
`v-model`本质就是一个语法糖，可以看成是`value + input`方法的语法糖。 可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。
## vue的双向数据绑定原理是什么
Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。
```html
<body>
	    <div id="app">
	    <input type="text" id="txt">
	    <p id="show"></p>
	</div>
	</body>
	<script type="text/javascript">
	    var obj = {}
	    Object.defineProperty(obj, 'txt', {
	        get: function () {
	            return obj
	        },
	        set: function (newValue) {
	            document.getElementById('txt').value = newValue
	            document.getElementById('show').innerHTML = newValue
	        }
	    })
	    document.addEventListener('keyup', function (e) {
	        obj.txt = e.target.value
	    })
	</script>
```
## Vue 组件中 data 为什么必须是函数
一个组件可能在很多地方使用，也就是会创建很多个实例，如果data是一个对象的话，对象是引用类型，一个实例修改了data会影响到其他实例，所以data必须使用函数，为每一个实例创建一个属于自己的data，使其同一个组件的不同实例互不影响。
## vue生命周期钩子函数有哪些

1. 在beforeCreate时，data和methods中的数据都还没有没初始化
2. 在created 中,data和methods都已经被初始化好了!如果要调用methods中的方法，或者操作data中的数据,最早，只能在created中操作,created通常用于异步请求，若想获取dom需要用this.$nextTick
3. 如果要通过某些插件操作页面上的DOM节点了，最早要在mounted 中进行
![16ca74f183827f46 2498×2798.png](https://cdn.nlark.com/yuque/0/2021/png/377749/1617852835300-21e2ab23-f304-4027-a24f-be62f4990872.png#align=left&display=inline&height=2798&margin=%5Bobject%20Object%5D&name=16ca74f183827f46%202498%C3%972798.png&originHeight=2798&originWidth=2498&size=276439&status=done&style=none&width=2498)
## vue created 能否获取dom
created钩子函数不能获取到dom元素 若想获取用 this.$nextTick()
## 组件之间是怎么通信的
**`props / $emit` 适用 父子组件通信**
**`ref` 与 `$parent / $children` 适用 父子组件通信**
**`EventBus （$emit / $on）` 适用于 父子、隔代、兄弟组件通信**
**`$attrs`/`$listeners` 适用于 隔代组件通信**
**`provide / inject` 适用于 隔代组件通信**
**Vuex 适用于 父子、隔代、兄弟组件通信**
## vue执行顺序
inject>state>props>methods>data>computed>watch>provide
## computed和watch,methods有什么区别
computed 有缓存性 ，一个数据受多个数据影响
watch 无缓存性 ，一个数据影响多个数据
methods 无缓存性，只要发生重新渲染，methods调用总会执行该函数
## vue3.0的六大亮点
1、组合API 2、先进的组件 3、更好的支持ts 4、性能提升 5、按需编译 6、自定义渲染的API
## 那你能讲一讲MVVM吗
MVVM是`Model-View-ViewModel`缩写，Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。
## keep-alive了解吗
`keep-alive`可以实现组件缓存，当组件切换时不会对当前组件进行卸载。
常用的两个属性`include/exclude`，允许组件有条件的进行缓存。
两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。
## mpvue与uni-app区别
- mpvue 不支持在 `template` 内使用 `methods` 中的函数
- mpvue 不支持支持过滤器 `filter`
- mpvue github star 20k uni-app github star 30k
## vuex
是什么：多组件共享数据抽离出来
为什么：因为普通的传值比较复杂不便于维护
## vue-amap Bug
// 页面刷新后，地图组件会报错
localStorage.clear() //修复报错
## 如何实现前端跨域
CORS
JSOP
postMessage
Iframe
## watch 怎么深度监听对象变化
deep 设置为 true 就可以监听到对象的变化
```javascript
let vm=new Vue({ el:"#first",
data:{msg:{name:'北京'}}, watch:{
msg:{
handler (newMsg,oldMsg){
console.log(newMsg); },
immediate:true,
deep:true }
} })
```
**

